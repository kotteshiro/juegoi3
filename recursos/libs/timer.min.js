function Timer(options) {
	var offset, clock,
		stopped = true, paused = true,
		usePerformance = window.performance !== undefined,
		dateObj = usePerformance ? window.performance : Date;
	this.interval
	// default options
	options = options || {};
	options.delay = options.delay || 1;
	options.onStart = options.onStart || function() {
		console.log("Timer Start!");
	}

	options.onTick = options.onTick || function(time) {
		console.log("Timer update!", time);
	};

	options.onReset = options.onReset || function(time) {
		console.log("Timer restarted!", time);
	};

	options.onStop = options.onStop || function(time) {
		console.log("Timer Stopped!", time);
	};
	
	options.onPause = options.onPause || function(time) {
		console.log("Timer paused!");
	};
	
	options.onResume = options.onResume || function(time) {
		console.log("Timer resumed!");
	};


	// initialize
	reset();
	
	function isStopped() {
		return this.stopped;
	}
	
	function isPaused() {
		return this.paused;
	}
	
	function isRunning() {
		return !this.paused && !this.stopped;
	}

	function start() {
		paused = stopped = false;
		
		if (!this.interval) {
			if(!paused) {
				offset = dateObj.now();
				options.onStart.call(this);
				this.interval = setInterval(update, options.delay);
			} else {
				console.log("The timer is paused, so please call resume instead.");
			}
		}
		options.onTick.call(this, clock);
		return this;
	}

	function stop() {
		if (this.interval) {
			if(this.cbstopdisablenext!=true)
            options.onStop.call(this, clock);
			this.cbstopdisablenext=false;
			clearInterval(this.interval);
			this.interval = null;
		}
		
		stopped = true;
		return this;
	}
	
	function pause() {
		if(this.interval) {
			options.onPause.call(this, clock); 
			clearInterval(this.interval);
			this.interval = null;
		}
		
		paused = true;
		return this;
	}
	
	function resume() {
		if(paused) {
			//if(options.onResume)
			options.onResume.call(this, clock);
			this.interval = setInterval(update, options.delay);
			paused = false;
			delta();
		}
		
		return this;
	}

	function reset() {
		clock = 0;
		return this;
	}

	function update() {
		clock += delta();
       	options.onTick.call(this, clock);
	}
	function gettime(){
		return clock;
	}
	function delta() {
		var now = dateObj.now(), d = now - offset;
		offset = now;
		return d;
	}
	
	function msToTime(s) {
  		var ms = s % 1000;
  		s = (s - ms) / 1000;
  		var secs = s % 60;
  		s = (s - secs) / 60;
  		var mins = s % 60;
  		//var hrs = (s - mins) / 60;
		var str = mins >= 10 ? mins : '0' + mins;

		if(secs >= 10)
			str += ':' + secs;
		else
			str += ':0' + secs;

  		return str;
	}
	function cancelNextCallBackAtStop(){
		this.cbstopdisablenext=true;
	}
	
	// public API
	this.start = start;
	this.stop = stop;
	this.reset = reset;
	this.format = msToTime;
	this.pause = pause;
	this.resume = resume;
	this.isRunning = isRunning;
	this.isStopped = isStopped;
	this.isPaused = isPaused;
	this.cancelNextCallBackAtStop=cancelNextCallBackAtStop;
	this.gettime=gettime;
}

function getMinutesFromMillis(millis) {
	var ms = millis % 1000;
	millis = (millis - ms) / 1000;
	var secs = millis % 60;
	millis = (millis - secs) / 60;
	return Math.round(millis % 60);
}