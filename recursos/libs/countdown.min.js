function CountDown(options) {
	var This=this;
	var offset, clock,
		stopped = true, paused = true,
		usePerformance = window.performance !== undefined,
		dateObj = usePerformance ? window.performance : Date;
	this.interval
	console.log("***** new CountDown *****");
	// default options
	options = options || {};
	options.delay = options.delay || 1;
	options.onStart = options.onStart || function() {
		console.log("Timer Start!");
	}

	options.onTick = options.onTick || function(time) {
		console.log("Timer update!", time);
	};

	options.onReset = options.onReset || function(time) {
		console.log("Timer restarted!", time);
	};

	options.onStop = options.onStop || function(time) {
		console.log("Timer Stopped!", time);
	};
	
	options.onPause = options.onPause || function(time) {
		console.log("Timer paused!");
	};
	
	options.onResume = options.onResume || function(time) {
		console.log("Timer resumed!");
	};

	// initialize
	reset();
	
	function isStopped() {
		return this.stopped;
	}
	
	function isPaused() {
		return this.paused;
	}
	
	function isRunning() {
		return !this.paused && !this.stopped;
	}

	function start(minutes) {
		clocktype="countDown";
		paused = stopped = false;
		if (!this.interval) {
			if(!paused) {
				offset = dateObj.now() + minutesToMillis(minutes);
				options.onStart.call(this);
				this.interval = setInterval(update, options.delay);
			} else {
				console.log("The timer is paused, so please call resume instead.");
			}
		}
		
		return this;
	}
    
    function minutesToMillis(minutes) {
        return minutes * 60000;
    }

	this.stop=function() {
		console.log("Stop called on countdown.");
		if (this.interval) {
			if(this.cbstopdisablenext!=true)
            options.onStop.call(this, clock);
			clearInterval(this.interval);
			this.interval = null;
			this.cbstopdisablenext=false;
		}
		
		stopped = true;
		return this;
	}
	
	function pause() {
		if(this.interval) {
			options.onPause.call(this, clock);
			clearInterval(this.interval);
			this.interval = null;
		}
		
		paused = true;
		return this;
	}
	
	function resume() {
		if(paused) {
			options.onResume.call(this, clock);
			this.interval = setInterval(update, options.delay);
			paused = false;
			delta();
		}
		
		return this;
	}

	function reset() {
		clock = 0;
		return this;
	}

	function update() {
		clock -= delta();
       	options.onTick.call(This, clock);
		
		if(clock <= 0) {
			reset();
			This.stopu();
		}
	}
	
	function addTime(ammount){
		clock+=ammount;
	}
	function delta() {
		var now = dateObj.now(), d = now - offset;
		offset = now;
		return d;
	}
	
	function msToTime(s) {
  		var ms = s % 1000;
  		s = (s - ms) / 1000;
  		var secs = s % 60;
  		s = (s - secs) / 60;
  		var mins = s % 60;
  		//var hrs = (s - mins) / 60;
		var str = mins >= 10 ? mins : '0' + mins;

		if(secs >= 10)
			str += ':' + secs;
		else
			str += ':0' + secs;

  		return str;
	}
	function cancelNextCallBackAtStop(){
		this.cbstopdisablenext=true;
	}
	
	function gettime(){
		return clock;
	}
	// public API
	this.start = start;
	this.addTime = addTime;
	this.stopu = this.stop;
	this.reset = reset;
	this.format = msToTime;
	this.pause = pause;
	this.resume = resume;
	this.isRunning = isRunning;
	this.isStopped = isStopped;
	this.isPaused = isPaused;
	this.cancelNextCallBackAtStop=cancelNextCallBackAtStop;
	this.gettime=gettime;
}